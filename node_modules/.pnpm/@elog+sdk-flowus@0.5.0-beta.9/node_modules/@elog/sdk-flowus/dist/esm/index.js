var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/client.ts
import { out as out2 } from "@elog/shared";
import { FlowUsClient as FlowUsApi } from "@flowusx/flowus-client";
import { FlowUsToMarkdown } from "@flowusx/flowus-to-md";

// src/utils.ts
import { out } from "@elog/shared";
import moment from "moment";
function formatDate(date) {
  return moment(date).format("YYYY-MM-DD HH:mm:ss");
}
function getPropVal(type, val, pageTitle) {
  if (!val)
    return "";
  switch (type) {
    case "text":
    case "email":
    case "url":
    case "select":
    case "number":
    case "phone":
      return val.text;
    case "file":
      out.debug(`\u3010${pageTitle}\u3011\u5B58\u5728\u6682\u4E0D\u652F\u6301\u7684\u5C5E\u6027\u7C7B\u578B:\u3010\u6587\u4EF6\u5A92\u4F53\u3011, \u5EFA\u8BAE\u5C06\u5176\u4E0A\u4F20\u5230\u56FE\u5E8A\u540E\u4F7F\u7528`);
      return "";
    case "checkbox":
      return val.text === "YES";
    case "formula":
      out.debug(`\u3010${pageTitle}\u3011\u5B58\u5728\u6682\u4E0D\u652F\u6301\u7684\u5C5E\u6027\u7C7B\u578B:\u3010\u516C\u5F0F\u3011`);
      return "";
    case "date":
      return val.startDate.replace("/", "-") + " " + val.startTime;
    case "multi_select":
      return val.text.split(",");
    case "person":
      out.debug(`\u3010${pageTitle}\u3011\u5B58\u5728\u6682\u4E0D\u652F\u6301\u7684\u5C5E\u6027\u7C7B\u578B:\u3010\u4EBA\u5458\u3011`);
      return "";
    default:
      return val.text || "";
  }
}
var isMultiArray = (arr) => {
  if (Array.isArray(arr)) {
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i])) {
        return true;
      }
    }
  }
  return false;
};
function props(pageBlock, tableBlock) {
  let properties = {};
  properties.urlname = pageBlock.uuid;
  properties.title = pageBlock.title;
  properties.updated = formatDate(pageBlock.updatedAt);
  properties.date = formatDate(pageBlock.createdAt);
  const pageProperties = pageBlock.data.collectionProperties;
  if (!pageProperties)
    return properties;
  const propIds = Object.keys(pageProperties);
  if (!propIds.length)
    return properties;
  propIds.forEach((propId) => {
    const propConfig = tableBlock.data.schema[propId];
    if (!propConfig)
      return;
    const propName = propConfig.name;
    const propType = propConfig.type;
    const propValList = pageProperties[propId].map((value) => {
      return getPropVal(propType, value, pageBlock.title);
    });
    if (!propValList.length)
      return;
    const isMulti = isMultiArray(propValList);
    let propVal;
    if (!isMulti) {
      propVal = propValList.join("");
    } else {
      propVal = propValList.flat().filter(Boolean);
    }
    if (!(propVal == null ? void 0 : propVal.length))
      return;
    properties[propName] = propVal;
  });
  return properties;
}
function genCatalog(page, property) {
  const catalog = page.properties[property];
  if (!catalog) {
    out.warning(`${page.properties.title} ${property} \u5C5E\u6027\u7F3A\u5931`);
    return void 0;
  } else if (typeof catalog === "string") {
    return [
      {
        title: catalog,
        doc_id: page.id
      }
    ];
  } else if (Array.isArray(catalog)) {
    return catalog.map((item) => {
      return {
        title: item,
        doc_id: page.id
      };
    });
  } else {
    out.warning(`${page.properties.title} \u6587\u6863\u5206\u7C7B\u4FE1\u606F\u63D0\u53D6\u5931\u8D25\uFF0C${property} \u5B57\u6BB5\u53EA\u80FD\u662F\u5355\u9009/\u591A\u9009`);
    return void 0;
  }
}
function sortDocs(docs, sorts) {
  return docs.sort((a, b) => {
    if (sorts) {
      let aSortValue = a.properties[sorts.property];
      let bSortValue = b.properties[sorts.property];
      const sortDirection = sorts.direction;
      if (!aSortValue || !bSortValue) {
        return 0;
      }
      if (Number.isNaN(Number(aSortValue)) || Number.isNaN(Number(bSortValue))) {
        if (moment(aSortValue).isValid() && moment(bSortValue).isValid()) {
          aSortValue = moment(aSortValue).valueOf();
          bSortValue = moment(bSortValue).valueOf();
        } else {
          return -1;
        }
      } else {
        aSortValue = Number(aSortValue);
        bSortValue = Number(bSortValue);
      }
      if (sortDirection === "ascending" /* ascending */) {
        return aSortValue - bSortValue;
      } else if (sortDirection === "descending" /* descending */) {
        return bSortValue - aSortValue;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  });
}
function filterDocs(docs, filter) {
  return docs.filter((page) => {
    const pageProperties = page.properties;
    if (filter && Array.isArray(filter)) {
      return filter.every((f) => {
        return pageProperties[f.property] === f.value;
      });
    } else if (typeof filter === "object") {
      return pageProperties[filter.property] === filter.value;
    }
    return true;
  });
}

// src/client.ts
import asyncPool from "tiny-async-pool";
var FlowUsClient = class {
  constructor(config) {
    this.catalog = [];
    this.config = config;
    this.config.tablePageId = config.tablePageId || process.env.FLOWUS_TABLE_PAGE_ID;
    if (!this.config.tablePageId) {
      out2.err("\u7F3A\u5C11\u53C2\u6570", "\u7F3A\u5C11 Table Page ID");
      process.exit(-1);
    }
    this.flowus = new FlowUsApi();
    this.f2m = new FlowUsToMarkdown({ client: this.flowus });
    this.initCatalogConfig();
    this.filterAndSortParams = this.initFilterAndSortParamsParams();
  }
  /**
   * 初始化目录配置
   */
  initCatalogConfig() {
    if (typeof this.config.catalog === "boolean") {
      if (!this.config.catalog) {
        this.config.catalog = { enable: false };
      } else {
        out2.access("\u5F00\u542F\u5206\u7C7B", "\u9ED8\u8BA4\u6309\u7167 catalog \u5B57\u6BB5\u5206\u7C7B\uFF0C\u8BF7\u68C0\u67E5FlowUs\u591A\u7EF4\u8868\u662F\u5426\u5B58\u5728\u8BE5\u5C5E\u6027");
        this.config.catalog = { enable: true, property: "catalog" };
      }
    } else if (typeof this.config.catalog === "object") {
      if (this.config.catalog.enable) {
        if (!this.config.catalog.property) {
          this.config.catalog.property = "catalog";
          out2.warning("\u672A\u8BBE\u7F6E\u5206\u7C7B\u5B57\u6BB5\uFF0C\u9ED8\u8BA4\u6309\u7167 catalog \u5B57\u6BB5\u5206\u7C7B\uFF0C\u8BF7\u68C0\u67E5FlowUs\u591A\u7EF4\u8868\u662F\u5426\u5B58\u5728\u8BE5\u5C5E\u6027");
        }
      }
    }
  }
  /**
   * 初始化过滤和排序参数
   */
  initFilterAndSortParamsParams() {
    let sort = this.config.sort;
    if (typeof this.config.sort === "boolean") {
      if (!this.config.sort) {
        sort = void 0;
      } else {
        sort = { property: "createdAt", direction: "descending" /* descending */ };
      }
    } else if (typeof this.config.sort === "string") {
      const sortPreset = this.config.sort;
      switch (sortPreset) {
        case "dateDesc" /* dateDesc */:
          sort = { property: "date", direction: "descending" /* descending */ };
          break;
        case "dateAsc" /* dateAsc */:
          sort = { property: "date", direction: "ascending" /* ascending */ };
          break;
        case "sortDesc" /* sortDesc */:
          sort = { property: "sort", direction: "descending" /* descending */ };
          break;
        case "sortAsc" /* sortAsc */:
          sort = { property: "sort", direction: "ascending" /* ascending */ };
          break;
        case "createTimeDesc" /* createTimeDesc */:
          sort = {
            property: "createdAt",
            direction: "descending" /* descending */
          };
          break;
        case "createTimeAsc" /* createTimeAsc */:
          sort = {
            property: "createdAt",
            direction: "ascending" /* ascending */
          };
          break;
        case "updateTimeDesc" /* updateTimeDesc */:
          sort = {
            property: "updatedAt",
            direction: "descending" /* descending */
          };
          break;
        case "updateTimeAsc" /* updateTimeAsc */:
          sort = {
            property: "updatedAt",
            direction: "ascending" /* ascending */
          };
          break;
        default:
          sort = {
            property: "createdAt",
            direction: "descending" /* descending */
          };
      }
    }
    let filter = this.config.filter;
    if (typeof this.config.filter === "boolean") {
      if (!this.config.filter) {
        filter = void 0;
      } else {
        filter = {
          property: "status",
          value: "\u5DF2\u53D1\u5E03"
        };
      }
    }
    return {
      filter,
      sort
    };
  }
  getPageList() {
    return __async(this, null, function* () {
      const pageBlocks = yield this.flowus.getDataTableData(this.config.tablePageId);
      const blocks = pageBlocks.blocks;
      const blocksKeys = Object.keys(blocks);
      const tableBlockKey = blocksKeys[0];
      const tableBlock = blocks[tableBlockKey];
      const pageIds = tableBlock.subNodes;
      const { filter, sort } = this.filterAndSortParams;
      let filterAndSortDoc = pageIds.map((pageId) => {
        const pageBLock = blocks[pageId];
        const properties = props(pageBLock, tableBlock);
        return {
          id: pageBLock.uuid,
          doc_id: pageBLock.uuid,
          title: pageBLock.title,
          updated: pageBLock.updatedAt,
          createdAt: pageBLock.createdAt,
          updatedAt: pageBLock.updatedAt,
          properties
        };
      });
      filterAndSortDoc = filterDocs(filterAndSortDoc, filter);
      filterAndSortDoc = sortDocs(filterAndSortDoc, sort);
      this.catalog = filterAndSortDoc;
      return filterAndSortDoc;
    });
  }
  download(page) {
    return __async(this, null, function* () {
      let body = "";
      try {
        const pageBlocks = yield this.flowus.getPageBlocks(page.id);
        body = this.f2m.toMarkdownString(pageBlocks);
      } catch (e) {
        out2.warning(`${page.title} \u4E0B\u8F7D\u51FA\u9519: ${e.message}`);
      }
      const doc = {
        id: page.id,
        properties: page.properties
      };
      let catalog;
      const catalogConfig = this.config.catalog;
      if (catalogConfig == null ? void 0 : catalogConfig.enable) {
        catalog = genCatalog(doc, catalogConfig.property);
      }
      return __spreadProps(__spreadValues({}, doc), {
        body,
        body_original: body,
        doc_id: page.id,
        updated: page.updated,
        catalog
      });
    });
  }
  getPageDetailList(cachedPages, ids) {
    return __async(this, null, function* () {
      let articleList = [];
      let pages = cachedPages;
      if (ids == null ? void 0 : ids.length) {
        pages = pages.filter((page) => {
          const exist = ids.indexOf(page.id) > -1;
          if (!exist) {
            const title = page.title;
            out2.info("\u8DF3\u8FC7\u4E0B\u8F7D", title);
          }
          return exist;
        });
      }
      if (!(pages == null ? void 0 : pages.length)) {
        out2.info("\u8DF3\u8FC7", "\u6CA1\u6709\u9700\u8981\u4E0B\u8F7D\u7684\u6587\u7AE0");
        return articleList;
      }
      out2.info("\u5F85\u4E0B\u8F7D\u6570", String(pages.length));
      out2.info("\u5F00\u59CB\u4E0B\u8F7D\u6587\u6863...");
      pages = pages.map((item, index) => __spreadProps(__spreadValues({}, item), { _index: index + 1 }));
      const promise = (page) => __async(this, null, function* () {
        out2.info(`\u4E0B\u8F7D\u6587\u6863 ${page._index}/${pages.length}   `, page.title);
        let article = yield this.download(page);
        articleList.push(article);
      });
      yield asyncPool(5, pages, promise);
      out2.info("\u5DF2\u4E0B\u8F7D\u6570", String(articleList.length));
      return articleList;
    });
  }
};
var client_default = FlowUsClient;

// src/core.ts
import { out as out3 } from "@elog/shared";
var FlowUs = class {
  constructor(config) {
    this.pages = [];
    this.config = config;
    this.ctx = new client_default(config);
  }
  /**
   * 获取文章列表（不含详情）
   */
  getDocList() {
    return __async(this, null, function* () {
      out3.info("\u6B63\u5728\u83B7\u53D6\u6587\u6863\u5217\u8868\uFF0C\u8BF7\u7A0D\u7B49...");
      const pages = yield this.ctx.getPageList();
      this.pages = pages;
      out3.info("\u6587\u6863\u603B\u6570", String(this.pages.length));
      return pages.map((page) => {
        return {
          // 暂时只需要返回这些属性
          id: page.id,
          doc_id: page.id,
          updated: page.updated
        };
      });
    });
  }
  /**
   * 获取文章详情列表
   * @param ids 需要下载的doc_id列表
   */
  getDocDetailList(ids) {
    return __async(this, null, function* () {
      return yield this.ctx.getPageDetailList(this.pages, ids);
    });
  }
};
var core_default = FlowUs;

// src/index.ts
var src_default = core_default;
export {
  src_default as default
};
//# sourceMappingURL=index.js.map